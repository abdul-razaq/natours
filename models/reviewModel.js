const mongoose = require('mongoose');

const Tour = require('./tourModel');

const reviewSchema = new mongoose.Schema(
  {
    review: {
      type: String,
      required: [true, 'review cannot be empty'],
    },
    rating: {
      type: Number,
      required: [true, 'A review must have a rating'],
      max: 5,
      min: 1,
    },
    createdAt: {
      type: Date,
      default: Date.now(),
    },
    tour: {
      type: mongoose.Schema.ObjectId,
      ref: 'Tour',
      required: [true, 'review must belong to a tour'],
    },
    user: {
      type: mongoose.Schema.ObjectId,
      ref: 'User',
      required: [true, 'review cannot be orphan'],
    },
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

reviewSchema.index({ tour: 1, review: 1 }, { unique: true });

reviewSchema.statics.calcAverageRatings = async function (tourId) {
  const stats = await this.aggregate([
    {
      $match: { tour: tourId },
    },
    {
      $group: {
        _id: '$tour',
        numRatings: { $sum: 1 },
        avgRating: { $avg: '$rating' },
      },
    },
  ]);
  if (stats.length > 0) {
    await Tour.findByIdAndUpdate(tourId, {
      ratingsQuantity: stats[0].numRatings,
      ratingsAverage: stats[0].avgRating,
    });
  } else {
    await Tour.findByIdAndUpdate(tourId, {
      ratingsQuantity: 0,
      ratingsAverage: 4.5,
    });
  }
};

reviewSchema.pre(/^find/, function (next) {
  // this.populate({
  //   path: 'user',
  //   select: 'name photo',
  // }).populate({
  //   path: 'tour',
  //   select: 'name',
  // });

  this.populate({
    path: 'user',
    select: 'name photo',
  });
  next();
});

reviewSchema.pre(/^findOneAnd/, async function(next) {
  // Here to get access to the current review document that is being updated or deleted in this query middleware, we had to execute the current query object so that we can have access to its returned document and then saved the returned document on the query object itself. Because we have access to the query object itself in the post middleware, we can STILL HAVE ACCESS to the current Review document (generated by executing the query object) that is being saved on the query object in this pre query middleware.
  this.doc = await this.findOne();
  next();
})

reviewSchema.post(/^findOneAnd/, async function() {
  // we perform the calculations for the tour number of ratings and also the average rating on the post middleware because by the time we get to this middleware, the query in the 'pre' middleware has already been executed, so the new, updated or deleted review has already been persisted to the database. Therefore we are able to calculate the average and total ratings on the real review data.
  await this.doc.constructor.calcAverageRatings(this.doc.tour);
});

reviewSchema.post('save', async function () {
  await this.constructor.calcAverageRatings(this.tour);
});

module.exports = mongoose.model('Review', reviewSchema);
